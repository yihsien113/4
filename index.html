<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>接龍記牌小工具 (復原/反復原功能 - 精簡版)</title>
  <style>
    /* ========== 深色模式基礎設定 ========== */
    body { 
      font-family: 'Microsoft JhengHei', Arial, sans-serif; 
      text-align: center; 
      background: #282c34; /* 深藍灰色背景 */
      color: #f0f0f0; /* 淺灰色文字 */
      font-size: 18px; 
      margin: 15px;
    }
    
    h2 {
      color: #61dafb; /* 亮藍色標題 */
      margin-bottom: 15px;
    }
    
    /* 頂部控制區：用於並排對齊「全部清除」和「選擇區」 */
    .top-selection {
        display: flex;
        justify-content: space-between; 
        align-items: center; 
        max-width: 650px; 
        margin: 10px auto;
    }

    /* 調整選擇區域，不再需要固定寬度 */
    .selection-area {
        display: flex;
        align-items: center; 
        width: auto; 
        justify-content: flex-end; 
    }

    /* ========== 通用按鈕樣式 ========== */
    button { 
      font-size: 20px;  
      margin: 4px; 
      padding: 8px 12px; 
      border-radius: 6px; 
      cursor: pointer;
      border: 1px solid #555; 
      background: #3a3f47; 
      color: #f0f0f0;
      min-width: 40px; 
      transition: background-color 0.2s;
      /* *** 修正雙擊縮放問題：新增此行 *** */
      touch-action: manipulation;
    }
    
    button:hover {
      background-color: #4c525d; 
    }

    /* 紅色花色文字 (只有文字變色) */
    .red-text-suit {
        color: #e74c3c !important; 
    }


    /* ========== 左側：全部清除按鈕 ========== */
    .clear-all { 
      background: #e74c3c; 
      box-shadow: 0 3px 0 #c0392b;
      width: 100px; 
      margin-right: 0; 
      font-size: 16px; 
      padding: 6px 8px; 
      flex-direction: row; 
      justify-content: center;
      flex-shrink: 0; 
    }
    .clear-all .clear-icon {
        font-size: 18px; 
        margin-right: 3px;
        margin-bottom: 0;
    }
    .clear-all:hover {
      background: #c0392b;
      transform: translateY(1px);
      box-shadow: 0 2px 0 #a03020;
    }


    /* ========== 選擇區域內元件樣式 ========== */

    /* 花色按鈕容器 (2x2) */
    .suit-group {
      display: grid;
      grid-template-columns: repeat(2, auto);
      gap: 1px; 
      margin-right: 8px; 
    }
    
    /* 花色按鈕加大 */
    .suit-group button {
        padding: 10px 10px; 
        font-size: 22px;
        min-width: 50px;
    }

    /* 數字按鈕容器 (A-6, 7-K) */
    .rank-group {
      display: flex;
      flex-direction: column;
    }

    /* 數字按鈕的每一行 */
    .rank-row { 
      display: flex;
      flex-wrap: nowrap;
      justify-content: flex-start;
      margin: 0;
      padding: 0;
    }

    /* ========== 記牌區總容器 & 側邊欄 ========== */
    .main-area {
      display: flex;
      justify-content: center;
      align-items: flex-start; 
      margin: 10px auto;
      max-width: 650px; 
    }
    
    /* 左側清除/復原按鈕區 */
    .sidebar-buttons {
      display: flex;
      flex-direction: column; 
      width: 90px; /* 縮小寬度 */
      margin-right: 30px; 
      padding-top: 5px; 
    }
    
    /* ========== 記牌槽網格 & 記牌槽樣式 (68px 尺寸) ========== */
    .grid { 
      display: grid; 
      grid-template-columns: repeat(6, 68px); /* 槽位寬度 68px */
      gap: 5px; 
      justify-content: center; 
      max-width: 510px; 
      padding: 5px;
      background: #3a3f47;
      border-radius: 10px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.5); 
    }
    
    .slot { 
      width: 68px;  /* 槽位寬度 68px */
      height: 50px; 
      font-size: 24px;  
      border: 3px solid #555; 
      border-radius: 8px;
      background: #1e1e1e;
      color: #f0f0f0; 
      margin: 0; 
      display: flex; 
      align-items: center;
      justify-content: center;
      font-weight: bold;
    }

    /* 確保紅色的花色 (♥, ♦) 在深色背景下保持紅色 (此為槽位內容) */
    .slot[style*="color: red"] {
        color: #ff6b6b !important; 
    }

    /* ========== 側邊清除按鈕樣式 (通用) - 縮小調整 ========== */
    .clear-button { 
      font-size: 16px; /* 縮小文字 */
      padding: 8px 8px; /* 縮小內邊距 */
      margin: 5px 0;
      border-radius: 6px;
      color: white; 
      border: none;
      width: 90px; /* 縮小寬度 */
      display: flex;
      flex-direction: column; 
      align-items: center;
    }

    .clear-icon {
      font-size: 24px; /* 縮小圖標 */
      margin-bottom: 2px; /* 微調間距 */
    }
    
    /* 清除空格按鈕 (綠色) */
    .clear-empty { 
      background: #2ecc71; 
      box-shadow: 0 3px 0 #27ae60;
    }
    .clear-empty:hover {
      background: #27ae60;
      transform: translateY(1px);
      box-shadow: 0 2px 0 #219d55;
    }

    /* 復原按鈕 (藍色) */
    .undo-button {
        background: #3498db; 
        box-shadow: 0 3px 0 #2980b9;
    }
    .undo-button:hover {
        background: #2980b9;
        transform: translateY(1px);
        box-shadow: 0 2px 0 #2071a1;
    }
    
    /* 反復原按鈕 (藍綠色) */
    .redo-button {
        background: #1abc9c; 
        box-shadow: 0 3px 0 #16a085;
    }
    .redo-button:hover {
        background: #16a085;
        transform: translateY(1px);
        box-shadow: 0 2px 0 #148f77;
    }

  </style>
</head>
<body>

  <h2>接龍記牌小工具 (最大記憶：200 步)</h2>

  <div class="top-selection">
      
      <button class="clear-all" onclick="clearAll()">
          <span class="clear-icon">❌</span>
          全部清除
      </button>

      <div class="selection-area">
          
          <div class="suit-group">
              <button onclick="selectSuit('♣')">♣</button>
              <button class="red-text-suit" onclick="selectSuit('♦')">♦</button>
              <button class="red-text-suit" onclick="selectSuit('♥')">♥</button>
              <button onclick="selectSuit('♠')">♠</button>
          </div>

          <div class="rank-group">
              <div class="rank-row">
                  <button onclick="selectRank('A')">A</button>
                  <button onclick="selectRank('2')">2</button>
                  <button onclick="selectRank('3')">3</button>
                  <button onclick="selectRank('4')">4</button>
                  <button onclick="selectRank('5')">5</button>
                  <button onclick="selectRank('6')">6</button>
              </div>
              <div class="rank-row">
                  <button onclick="selectRank('7')">7</button>
                  <button onclick="selectRank('8')">8</button>
                  <button onclick="selectRank('9')">9</button>
                  <button onclick="selectRank('10')">10</button>
                  <button onclick="selectRank('J')">J</button>
                  <button onclick="selectRank('Q')">Q</button>
                  <button onclick="selectRank('K')">K</button>
              </div>
          </div>
      </div>
  </div>
  
  <div class="main-area">
      <div class="sidebar-buttons">
          
          <button class="clear-button clear-empty" onclick="removeEmptySlots()">
              <span class="clear-icon">🗑️</span>
              清除空格
          </button>
          
          <button class="clear-button undo-button" onclick="undo()">
              <span class="clear-icon">↶</span>
              復原
          </button>
          
          <button class="clear-button redo-button" onclick="redo()">
              <span class="clear-icon">↱</span>
              反復原
          </button>

      </div>
      
      <div class="grid" id="slots"></div>
  </div>


  <script>
    let selectedSuit = '';
    let selectedRank = '';
    
    // ========== 復原/反復原功能核心變數與函數 ==========
    let history = [];
    let redoStack = []; // 用於反復原的堆疊
    const MAX_HISTORY = 200; // ***已調整為 200 個步驟***

    function getCurrentState() {
        const slots = document.querySelectorAll('.slot');
        return Array.from(slots).map(s => {
            return {
                content: s.innerText,
                color: s.style.color
            };
        });
    }

    function loadState(state) {
        const slots = document.querySelectorAll('.slot');
        if (state.length !== slots.length) return; 

        slots.forEach((s, index) => {
            const item = state[index];
            s.innerText = item.content;
            s.style.color = item.color || '#f0f0f0'; 
        });
    }

    function saveState() {
        const currentState = getCurrentState();
        
        // 檢查是否與最後一個歷史狀態相同，防止重複儲存
        if (history.length > 0) {
            const lastState = history[history.length - 1];
            if (JSON.stringify(lastState) === JSON.stringify(currentState)) {
                return; 
            }
        }

        // 限制歷史記錄數量
        if (history.length >= MAX_HISTORY) {
            history.shift(); // 刪除最舊的狀態
        }
        history.push(currentState);
    }

    /**
     * 復原上一個動作 (載入上一個儲存的狀態)
     */
    function undo() {
        // 如果歷史記錄少於或等於 1 (只剩下初始狀態)，則不能復原
        if (history.length <= 1) {
            return;
        }
        
        // 1. 儲存當前狀態到 Redo 堆疊
        const currentState = history.pop(); 
        redoStack.push(currentState);
        
        // 2. 載入新的「最新」狀態 (即上一步操作前的狀態)
        const previousState = history[history.length - 1];
        loadState(previousState);
    }

    /**
     * 反復原 (重做) 上一個被復原的動作
     */
    function redo() {
        // Redo 堆疊為空時，不能反復原
        if (redoStack.length === 0) {
            return;
        }

        // 1. 從 Redo 堆疊取出狀態
        const nextState = redoStack.pop();
        
        // 2. 載入該狀態
        loadState(nextState);

        // 3. 將該狀態重新推回 History 陣列
        history.push(nextState);
    }
    // ========== 復原/反復原功能核心變數與函數 (結束) ==========


    // ==========================================================
    // ** 關鍵修正：確保所有動作在儲存新狀態前清空 Redo 堆疊 **
    // ==========================================================

    function selectSuit(suit) {
      selectedSuit = suit;
    }

    function selectRank(rank) {
      selectedRank = rank;
    }

    function fillSlot(btn) {
      // 任何新動作前，清空 Redo 堆疊
      if (redoStack.length > 0) {
          redoStack = []; 
      }

      // 執行動作
      if (selectedSuit && selectedRank) {
        btn.innerText = selectedSuit + selectedRank;
        btn.style.color = (selectedSuit === '♥' || selectedSuit === '♦') ? 'red' : '#f0f0f0'; 
        selectedSuit = '';
        selectedRank = '';
      } else if (!selectedSuit && !selectedRank) {
        btn.innerText = '';
        btn.style.color = '#f0f0f0'; 
      }
      
      // 動作完成後儲存狀態
      saveState(); 
    }

    function clearAll() {
      // 任何新動作前，清空 Redo 堆疊
      if (redoStack.length > 0) {
          redoStack = []; 
      }

      // 執行動作
      const slots = document.querySelectorAll('.slot');
      slots.forEach(s => {
        s.innerText = '';
        s.style.color = '#f0f0f0';
      });

      // 動作完成後儲存狀態
      saveState(); 
    }

    function removeEmptySlots() {
      // 任何新動作前，清空 Redo 堆疊
      if (redoStack.length > 0) {
          redoStack = []; 
      }

      // 執行動作
      const slots = Array.from(document.querySelectorAll('.slot'));
      const nonEmpty = slots.filter(s => s.innerText !== '');
      const slotsContainer = document.getElementById('slots');
      
      // 清空容器並重新加入非空元素
      slotsContainer.innerHTML = '';
      nonEmpty.forEach(s => {
        slotsContainer.appendChild(s);
      });
      
      // 補齊空的按鈕，維持 36 個槽位
      const totalSlots = 36;
      for (let i = nonEmpty.length; i < totalSlots; i++) {
        let b = document.createElement('button');
        b.className = 'slot';
        b.onclick = () => fillSlot(b);
        slotsContainer.appendChild(b);
      }
      
      // 動作完成後儲存狀態
      saveState(); 
    }

    // 初始化 36 個記牌槽
    const slotsContainer = document.getElementById('slots');
    for (let i = 0; i < 36; i++) {
      let b = document.createElement('button');
      b.className = 'slot';
      b.onclick = () => fillSlot(b);
      slotsContainer.appendChild(b);
    }

    // 頁面載入後，儲存初始狀態
    window.onload = function() {
        saveState(); 
    }
  </script>

</body>
</html>